## Basic Concepts
This is an highly customizable, opinionted integration of React and jsPlumb with two main principles:

1. DOM rendering is handled by React and state changes
1. Connection and drag functionality is handled by jsPlumb

This means that this library assumes lots of state changes as a result of user interactions (mouse clicks, dragging, dropping, etc.) and is optimized to handle these use cases. These state changes will need to occur inside of user-defined callbacks. When no callbacks are provided, the library still works, but it breaks from best practices in the React community, so we advise against it.

## Asynchronous Creation of Nodes/Connections
We may not want to create a node or a connection until validation has occured by the server or a unique ID has been generated by the server. If this is the case, we need to allow developers to pass their handler asynchronously. (Perhaps something similar to express with argument count? Or another method?)

## Data Types
We will track components by their ID. We can also allow an ID generator function to be passed in the configuration (with a default UUID generator provided).

Think about temporary IDs. It is possible that the client-generated ID will (initially) only be for jsPlumb. After the server has generated a new ID for the connection, we need to be able to replace it.

Perhaps provide a `generateId()` and `generateIdAsync()`. The async version will generate a temporary ID for the component and replace it once the server responds, allowing the frontend to work seemlessly (prefix with `tmp:` for temporary ids)

### Nodes

```js
const node = {
    id: "",
    x: 0,
    y: 0,
    endpoints: [
        {
            id: "",
            scope: "",          // Can be an array
            position: "",       // If left undefined, the continuous anchor will be used
            default: true,      // Optional. Indicates this is the endpoint to use if no other endpoint is specified
            isSource: true,
            isTarget: true
            // Additional jsPlumb configuration goes here
            // ...
        }
    ]
}
```

We expect node configuration to include at least the properties explicitly listed above. Our opinionated implementation depends on it. If no ID is provided, then the library will generate one according to the default or the developer-provided generators.

#### Node Endpoints and jsPlumb Anchors
We will provide functions to generate jsPlumb anchors, along with additional predefined anchors moving counter-clockwise from the top left corner of the node in the following way:

```
TOP_LEFT            RIGHT_TOP               BOTTOM_RIGHT            LEFT_BOTTOM
TOP_LEFT_MIDDLE     RIGHT_TOP_MIDDLE        BOTTOM_RIGHT_MIDDLE     LEFT_BOTTOM_MIDDLE
TOP_MIDDLE          RIGHT_MIDDLE            BOTTOM_MIDDLE           LEFT_MIDDLE
TOP_MIDDLE_RIGHT    RIGHT_MIDDLE_BOTTOM     BOTTOM_MIDDLE_LEFT      LEFT_MIDDLE_TOP
TOP_RIGHT           RIGHT_BOTTOM            BOTTOM_LEFT             LEFT_TOP
```

The first direction indicates the side out of/into which arrows will flow (depending on if it is a target or source node).

These will all have different meanings depending on the shape of the node. The library supports all of the jsPlumb supported node shapes.

Initially there will only be support for static anchors.

### Connections

```js
const conn = {
    id: "",
    scope: "",
    source: {
        id: "",
        endpoint: ""
    },
    target: {
        id: "",
        endpoint: ""
    }
    // Additional jsPlumb configuration goes here
    // ...
}
```

If the endpoint in a connection is undefined, then the "default" endpoint will be used. You can specify a default endpoint in the `endpoints` property. If no default is specified, one will be chosen at random by jsPlumb.

Connections are the trickiest part because their visual representation is created by jsPlumb. The way we handle this is by intercepting the drop handler and determining for ourselves if it is a legal connection. If the answer is yes, a callback is fired and state is expected to change. If the answer is no, the callback will not be fired and jsPlumb will halt trying to render the connection. In order for this to work, **all connections must have a unique identifier**.


## Scopes
Should be able to restrict connections to matching scopes (or a list of scopes). If a scope is specified, scopes must match for a connection to be successful. There is an `onDropMismatchedScope()` callback that can be registered that is called when scopes are defined and a connection is attempted between mismatching scopes. This allows alerts, notifications, or other cleanup to occur on the part of the developer.

The registered scope can be an array of string values. In this case, a connection works only if two scopes match. The first scope to match will be the one used unless otherwise specified in the connection data structure.

## jsPlumb Exposure
This is essentially an opinionated integration of jsPlumb for React. We need to provide a way for the developer to configure the jsPlumb instance with raw properties if they need more customization. Easiest way to do this is to expose the jsPlumb data types that are returned in callbacks for event handlers as a final argument.

## Re-rendering
Normally React has complete control over DOM manipulation. With jsPlumb, this is not the case. jsPlumb creates and destroyes the DOM elements that visual represent connections between nodes. When a re-render is triggered in React, there must be a way to ensure that connections are not duplicated or lost between re-renders. React Plumb will track the state of the connections internally and draw/remove connections by comparing it with the connection state being passed to the hook.

This method **requires** the use of IDs for all connections. Strict compliance to the minimum set of properties for the node and connection objects described above will guarantee a smooth experience with React Plumb.

## Connection Callbacks
The connection data structure defined above is passed back in the same format in callbacks on connection events. Note that whatever data you decide to extend the data structure definition with will also be available in the callback. 